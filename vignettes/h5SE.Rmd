---
title: "h5SE -- experiments with delayed HDF5 export/import for SummarizedExperiments"
author: "Vincent J. Carey, stvjc at channing.harvard.edu"
date: "`r format(Sys.time(), '%B %d, %Y')`"
vignette: >
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteIndexEntry{h5DSE: Out-of-memory illustrations for SummarizedExperiment}
  %\VignetteEncoding{UTF-8}
output:
  BiocStyle::pdf_document:
    toc: yes
    number_sections: yes
  BiocStyle::html_document:
    highlight: pygments
    number_sections: yes
    theme: united
    toc: yes
---

# Introduction

We want to get some background on the use of HDF5 and DelayedArray
infrastructure for modest-size assay sets.

We'll work with some 450k data.
```{r setup}
suppressPackageStartupMessages({
library(SummarizedExperiment)
library(HDF5Array)
library(yriMulti)
if (!exists("banovichSE")) data(banovichSE)
})
banovichSE
```

# Export a standard RangedSummarizedExperiment

Let's use the newly defined method for exporting the
assay component of a SummarizedExperiment:
```{r donew}
library(benchOOM)
tf = tempfile()
dir.create(tf)
banoSE = saveHDF5SummarizedExperiment(banovichSE, tf, replace=TRUE)
banoSE
```

Access capabilities:
```{r usenew}
assay(banoSE[1,])
subsetByOverlaps(banoSE, rowRanges(banoSE)[1001:1010])
```

# Import a packaged HDF5RangedSummarizedExperiment

```{r lkmm}
litg = getLitGeu()
litg
```

# Benchmarking exercise

We want to create a spectrum of biologically meaningful queries.  To
this end we introduced the gobrowse and go2ranges functions.  
```{r bb}
library(Organism.dplyr)
if (file.exists("~/hg19.sqlite")) 
  hg19 = src_organism(dbpath="~/hg19.sqlite") else {
  library(TxDb.Hsapiens.UCSC.hg19.knownGene)
  hg19 = src_organism(TxDb.Hsapiens.UCSC.hg19.knownGene)
  }
r1 = go2ranges("transmembrane receptor activity", hg19) # length 2302
length(r1)
library(microbenchmark)
microbenchmark(as.array(assay(subsetByOverlaps(banovichSE, r1[1:20]))), times=5)
microbenchmark(as.array(assay(subsetByOverlaps(banoSE, r1[1:10]))), times=5)
# also include an exported, sorted GenomicRanges ... metadata work may be needed
```

This shows that the speed of getting a delayed array corresponding to a large
pathway is similar if the base data are on disk in HDF5 or in memory.

However, applying as.array to get the results into memory seems
slow for this particular request, and this could have something to do
with the order of the rows as specified in the request.  They
may be scattered throughout the HDF5 store, and costly to recover
together, in the order returned by the in memory request.  Needs
more investigation.

There is an indication that if the records requested are contiguous
rows, the as.array moves quickly...
